% db_aln_interface.m
% Deterministic SQL/ALN bridge between blood typing, biomech features,
% nanoswarm nodes, and neuromod neuromodulation envelopes under
% IEC 62304 / ISO 14971‑style constraints.[web:3][web:6][web:9]

function q = db_aln_interface(op, args)
% db_aln_interface
% op   : string selector
% args : struct with required fields per op
%
% This function emits parametrized SQL fragments that align with:
%   - db/clinical_bioaug_schema.sql (PostgreSQL 17)
%   - aln/actuator_guard_binding.aln neuromod guard contract
%
% Returned value:
%   q : struct with fields
%       .sql  : UTF‑8 SQL text (with $1, $2, ... placeholders)
%       .bind : cell array of parameter names (for the caller to map)
%
% No execution is performed here: this is a pure, side‑effect‑free
% interface description suitable for compiled ALN or MATLAB bindings.

    switch op
        case 'insert_subject_with_blood'
            % Inputs expected in args:
            %   args.subject_hash       : BYTEA/uint8 vector
            %   args.cohort_id          : int32
            %   args.birth_year         : int16
            %   args.sex_code           : int16   (0–3)
            %   args.region_code_iso3166: int16
            %   args.augmentation_level : int16   (0–3)
            %   args.abo_group          : char    ('O','A','B','AB')
            %   args.rh_factor          : char    ('POS','NEG')
            %
            % Transactional upsert for subject, resolving blood_type FK.
            q.sql = [
                "WITH bt AS (" ...
                "  SELECT id AS blood_type_id" ...
                "  FROM blood_type" ...
                "  WHERE abo_group = $1" ...
                "    AND rh_factor = $2" ...
                "), ins AS (" ...
                "  INSERT INTO subject_registry (" ...
                "    subject_hash, cohort_id, birth_year, sex_code," ...
                "    region_code_iso3166, augmentation_level, blood_type_id" ...
                "  ) SELECT " ...
                "    $3::BYTEA, $4::INTEGER, $5::SMALLINT, $6::SMALLINT," ...
                "    $7::SMALLINT, $8::SMALLINT, bt.blood_type_id" ...
                "  FROM bt" ...
                "  RETURNING subject_id" ...
                ")" ...
                " SELECT subject_id FROM ins;"
            ];
            q.bind = { ...
                'abo_group', ...
                'rh_factor', ...
                'subject_hash', ...
                'cohort_id', ...
                'birth_year', ...
                'sex_code', ...
                'region_code_iso3166', ...
                'augmentation_level' ...
            };

        case 'bind_biomech_feature_to_subject'
            % Inputs in args:
            %   args.subject_id              : UUID
            %   args.feature_class           : ENUM feature_class
            %   args.control_mode            : ENUM control_mode
            %   args.safety_tier             : ENUM safety_tier
            %   args.connector_code          : int16
            %   args.channels_total          : int16
            %   args.sense_channels          : int16
            %   args.actuate_channels        : int16
            %   args.sense_voltage_max_mv    : int16
            %   args.actuate_voltage_max_mv  : int16
            %   args.isolation_min_megaohm   : single
            %   args.sample_rate_hz          : single
            %   args.latency_budget_ms       : single
            %   args.jitter_max_us           : single
            %   args.body_region_code        : int16
            %   args.tissue_depth_mm         : single
            %   args.biocompat_score_01      : single
            %   args.aln_semantic_ptr        : int64
            q.sql = [
                "INSERT INTO biomech_feature (" ...
                "  subject_id, feature_class, control_mode, safety_tier," ...
                "  connector_code, channels_total, sense_channels, actuate_channels," ...
                "  sense_voltage_max_mv, actuate_voltage_max_mv," ...
                "  isolation_min_megaohm, sample_rate_hz, latency_budget_ms," ...
                "  jitter_max_us, body_region_code, tissue_depth_mm," ...
                "  biocompat_score_01, aln_semantic_ptr" ...
                ") VALUES (" ...
                "  $1::UUID, $2::feature_class, $3::control_mode, $4::safety_tier," ...
                "  $5::SMALLINT, $6::SMALLINT, $7::SMALLINT, $8::SMALLINT," ...
                "  $9::SMALLINT, $10::SMALLINT," ...
                "  $11::REAL, $12::REAL, $13::REAL," ...
                "  $14::REAL, $15::SMALLINT, $16::REAL," ...
                "  $17::REAL, $18::BIGINT" ...
                ") RETURNING feature_id;"
            ];
            q.bind = { ...
                'subject_id', ...
                'feature_class', ...
                'control_mode', ...
                'safety_tier', ...
                'connector_code', ...
                'channels_total', ...
                'sense_channels', ...
                'actuate_channels', ...
                'sense_voltage_max_mv', ...
                'actuate_voltage_max_mv', ...
                'isolation_min_megaohm', ...
                'sample_rate_hz', ...
                'latency_budget_ms', ...
                'jitter_max_us', ...
                'body_region_code', ...
                'tissue_depth_mm', ...
                'biocompat_score_01', ...
                'aln_semantic_ptr' ...
            };

        case 'bind_nano_node_to_subject'
            % Inputs in args:
            %   args.node_id            : UUID
            %   args.subject_id         : UUID
            %   args.ops_threshold_tops : double
            %   args.qpu_topology_matrix: double matrix
            %   args.compliance_level   : string
            %   args.ai_firmware_version: string
            %   args.thermal_ceiling_w  : single
            %   args.power_floor_w      : single
            %   args.duty_cycle_max_pct : single
            %   args.reliability_vector : double vector
            %   args.latency_vector_ms  : double vector
            %   args.firmware_hash      : uint8 vector
            q.sql = [
                "INSERT INTO nano_node (" ...
                "  node_id, subject_id, ops_threshold_tops," ...
                "  qpu_topology_matrix, compliance_level, ai_firmware_version," ...
                "  thermal_ceiling_w, power_floor_w, duty_cycle_max_pct," ...
                "  reliability_vector, latency_vector_ms, firmware_hash" ...
                ") VALUES (" ...
                "  $1::UUID, $2::UUID, $3::NUMERIC(12,2)," ...
                "  $4::DOUBLE PRECISION[]," ...
                "  $5::TEXT, $6::TEXT," ...
                "  $7::REAL, $8::REAL, $9::REAL," ...
                "  $10::DOUBLE PRECISION[], $11::DOUBLE PRECISION[], $12::BYTEA" ...
                ");"
            ];
            q.bind = { ...
                'node_id', ...
                'subject_id', ...
                'ops_threshold_tops', ...
                'qpu_topology_matrix', ...
                'compliance_level', ...
                'ai_firmware_version', ...
                'thermal_ceiling_w', ...
                'power_floor_w', ...
                'duty_cycle_max_pct', ...
                'reliability_vector', ...
                'latency_vector_ms', ...
                'firmware_hash' ...
            };

        case 'neuromod_check_and_snapshot'
            % SQL side of aln/actuator_guard_binding.aln:
            %
            % Inputs:
            %   args.feature_id          : int64
            %   args.subject_id          : UUID
            %   args.timestamp_ms        : int64 (external clock, optional)
            %   args.security_state      : ENUM security_state
            %   args.threat_flag         : ENUM threat_flag
            %   args.anomaly_score_01    : single
            %   args.attack_surface_score: single
            %
            % This is the generic SQL template that the ALN action fills
            % once the envelope has been evaluated as SAFE_OFF.
            q.sql = [
                "INSERT INTO security_snapshot (" ...
                "  feature_id, subject_id, timestamp_ms," ...
                "  security_state, threat_flag," ...
                "  pqc_enabled, hw_root_of_trust, secure_boot, isolation_enforced," ...
                "  anomaly_score_01, attack_surface_score, last_update_delta_ms" ...
                ") VALUES (" ...
                "  $1::BIGINT, $2::UUID, $3::BIGINT," ...
                "  $4::security_state, $5::threat_flag," ...
                "  TRUE, TRUE, TRUE, TRUE," ...
                "  $6::REAL, $7::REAL, 0" ...
                ");"
            ];
            q.bind = { ...
                'feature_id', ...
                'subject_id', ...
                'timestamp_ms', ...
                'security_state', ...
                'threat_flag', ...
                'anomaly_score_01', ...
                'attack_surface_score' ...
            };

        case 'trace_hazard_binding'
            % IEC 62304 / ISO 14971 traceability wiring.[web:3][web:6][web:9]
            %
            % Inputs:
            %   args.profile_id  : TEXT (e.g., 'BioAugClinical')
            %   args.hazard_id   : TEXT
            %   args.control_id  : TEXT
            %   args.policy_id   : TEXT
            %   args.backend_mod : TEXT
            q.sql = [
                "WITH sprof AS (" ...
                "  INSERT INTO safety_profile (profile_id, iec_62304_class, iso_14971_profile)" ...
                "  VALUES ($1, 'C', 'HighHazardNeuromod')" ...
                "  ON CONFLICT (profile_id) DO NOTHING" ...
                "  RETURNING profile_id" ...
                "), shaz AS (" ...
                "  INSERT INTO hazard_registry (hazard_id, profile_id, description, severity_code, probability_code)" ...
                "  VALUES ($2, $1, 'Unintended actuator overdrive', 'Catastrophic', 'P2')" ...
                "  ON CONFLICT (hazard_id) DO NOTHING" ...
                "  RETURNING hazard_id" ...
                "), sctrl AS (" ...
                "  INSERT INTO control_registry (control_id, hazard_id, control_type)" ...
                "  VALUES ($3, $2, 'ProtectiveLimit')" ...
                "  ON CONFLICT (control_id) DO NOTHING" ...
                "  RETURNING control_id" ...
                "), spol AS (" ...
                "  INSERT INTO policy_binding (policy_id, hazard_id, control_id, backend_module, backend_test_id)" ...
                "  VALUES ($4, $2, $3, $5, 'test_safe_off_on_error')" ...
                "  ON CONFLICT (policy_id) DO NOTHING" ...
                "  RETURNING policy_id" ...
                ")" ...
                " INSERT INTO trace_link (hazard_id, control_id, policy_id, backend_module)" ...
                " SELECT $2, $3, $4, $5" ...
                " ON CONFLICT DO NOTHING;"
            ];
            q.bind = { ...
                'profile_id', ...
                'hazard_id', ...
                'control_id', ...
                'policy_id', ...
                'backend_module' ...
            };

        otherwise
            error('Unknown op selector: %s', op);
    end
end
